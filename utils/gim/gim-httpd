#!/usr/bin/env python
'''
The HTTP service for GIM
'''
import os
import sys
import json
import ConfigParser

from BaseHTTPServer import HTTPServer
from BaseHTTPServer import BaseHTTPRequestHandler
from SocketServer import ThreadingMixIn
from optparse import OptionParser
from urlparse import urlparse

from daemon import Daemon
from gim import Compose
from gim import ComposeAttrError
from gim import GuestISOManager

BASE_DIR = os.path.dirname(os.path.abspath(__file__))
GMANAGER = None


class JSONMessage(object):

    def __init__(self, msg_obj):
        self.msg_obj = json.dumps(msg_obj)

    def __str__(self):
        return str(self.msg_obj)

    def __repr__(self):
        return self.__str__()

    def __len__(self):
        return len(self.__str__())


class Message(JSONMessage):

    def __init__(self, msg=''):
        super(Message, self).__init__({'return': msg})


class ErrMessage(JSONMessage):

    def __init__(self, msg=''):
        super(ErrMessage, self).__init__({'error': msg})


def request_handler(func):

    def wrap_func(request):
        try:
            return func(request)
        except:
            return (500, ErrMessage('Internal Server Error'))

    return wrap_func

@request_handler
def query_status(request):
    return (200, Message(0))


@request_handler
def not_found(request):
    return (404, ErrMessage('Not Found'))


@request_handler
def gim_read_log(request):
    global GMANAGER
    try:
        return (200, GMANAGER.read_log())
    except:
        return (500, ErrMessage('Internal Server Error'))


def gim_compose_call_handler(func):

    def wrap_func(request):
        compose_id = request.get('compose_id', '').strip()
        if not compose_id:
            return (200, ErrMessage("Param 'compose_id' Is Empty"))
        arch = request.get('arch', '').strip()
        if not arch:
            return (200, ErrMessage("Param 'arch' Is Empty"))
        variant = request.get('variant', 'Server').strip()

        try:
            return (200, func(Compose(compose_id, variant, arch)))
        except ComposeAttrError, e:
            return (200, ErrMessage(str(e)))

    return wrap_func


@request_handler
@gim_compose_call_handler
def gim_update(compose):
    global GMANAGER
    return Message(GMANAGER.submit_task(compose))


@request_handler
@gim_compose_call_handler
def gim_submit_task(compose):
    global GMANAGER
    return Message(GMANAGER.has_task(compose))


@request_handler
def gim_info_task(request):
    global GMANAGER
    if request.has_key('compose_id'):
        return gim_submit_task(request)
    return (200, Message(GMANAGER.get_all_tasks()))


@request_handler
@gim_compose_call_handler
def gim_info_symlink(compose):
    global GMANAGER
    return Message(GMANAGER.need_to_update(compose))


class GIMRequestHandler(BaseHTTPRequestHandler):

    protocol_version = 'HTTP/1.1'
    response_handler = {
        '/gim/update': gim_update,
        '/gim/info/task': gim_info_task,
        '/gim/info/symlink': gim_info_symlink,
        '/gim/log': gim_read_log,
        '/': query_status
    }

    def respond_json(self, code, content):
        headers = {
            'Content-Type': 'text/plain; charset=UTF-8',
            'Content-Length': str(len(content)),
            'Cache-Control': 'no-cache'
        }
        self.send_response(code)
        for (key, value) in headers.items():
            self.send_header(key, value)
        self.end_headers()
        self.wfile.write(str(content))

    def do_GET(self):
        path_parser = urlparse(self.path)
        request = {}
        if path_parser.query:
            for keyval in path_parser.query.split('&'):
                request[keyval.split('=')[0]] = keyval.split('=')[1]
        responser = self.response_handler.get(path_parser.path,
                                              not_found)
        self.respond_json(*responser(request))


class ThreadingHTTPServer(ThreadingMixIn, HTTPServer):

    pass


class HTTPDaemon(Daemon):

    def run(self):
        global BASE_DIR
        global GMANAGER
        cfg_path = os.path.join(BASE_DIR, 'config.ini')
        log_path = os.path.join(BASE_DIR, 'gim.log')

        parser = ConfigParser.ConfigParser()
        parser.read(cfg_path)

        top_url = parser.get('gim', 'top_url')
        isos_dir = parser.get('gim', 'isos_dir')
        keep_old = bool(parser.get('gim', 'keep_old') == 'yes')
        nightly_first = bool(parser.get('gim', 'nightly_first') == 'yes')
        GMANAGER = GuestISOManager(top_url, isos_dir, keep_old,
                                   nightly_first, log_path)

        server_addr = (str(parser.get('httpd', 'host')),
                       int(parser.get('httpd', 'port')))
        httpd = ThreadingHTTPServer(server_addr, GIMRequestHandler)

        httpd.serve_forever()
        httpd.server_close()


def parse_args():
    cmdlist = ['start', 'stop', 'restart']
    usage = 'Usage: %prog ' + '|'.join(cmdlist)

    parser = OptionParser(usage=usage)
    (opts, args) = parser.parse_args()

    if len(args) != 1 or (args[0] not in cmdlist):
        parser.print_usage()
        sys.stderr.write('Unknown command\n')
        sys.exit(0)

    return args[0]


if __name__ == '__main__':
    cmd = parse_args()
    pid_file_path = os.path.join('/var/run', 'gim.pid')
    daemon = HTTPDaemon(pid_file_path)

    func = getattr(daemon, cmd)
    func()
